#Stochastic functions
"""
    get_markov_pairs(c)

    Returns the counts for the elements and pairs of consecutive elements of
    a given sequence c.

    The output are two dictionaries, each of them having symbols as keys
    and counts as values.
"""
function get_markov_pairs(c)
    #Tm = Dict{Any,Int64}()
    T = Dict{Any,Int64}()
    xy = join(["***" c[1]], "+") #first element.
    T[xy] = get(T, xy,0) + 1
    #Tm[c[1]] = get(Tm,c[1],0)+1
    for i = 1:length(c)-1
        #Tm[c[i+1]] = get(Tm,c[i+1],0)+1
        xy = join([c[i] c[i+1]],"+")
        T[xy] = get(T, xy,0) + 1
    end
    return T# Tm
end

"""
    get_key_TM(kseq; nall_keys=nall_keys, norm=false)

    Returns a
"""
function get_key_TM(kseq; nall_keys=nall_keys) #Transition matrix of keys
    n_e = length(nall_keys)
    T_M = zeros(Int64,n_e,n_e)
    for i = 1:length(kseq)-1
        k_i = findfirst(x-> x==kseq[i], nall_keys)
        k_j = findfirst(x-> x==kseq[i+1], nall_keys)
        T_M[k_i, k_j] += 1
    end
    return T_M
end
"""
    gen_rwalk_seq(T_M::Array{Int64,2},t_max; p_nov=0.0,i_state=0)

    Returns a sequence generated by doing a random walk over a transition matrix,
    the transition matrix can be or not normalized.

    The initial state is given by the variable i_state âˆˆ {1,...,N}, which by default is 0,
    meaning it is not defined and will pick an existing state radonmly.

    The variable p_nov is the chance of generating a new state -e.g. a transition to
    a state never visited before-
"""
function gen_rwalk_seq(T_M, t_max, tokens; p_nov=0.0, i_state=0)
    #t_list = findall(x-> x!=0, T_M) #looks at the transitions already created.
    states = first.(Tuple.(findall(!iszero,T_M)))
    if i_state == 0
        p_i = rand(unique(states)) #chooses randomly one initial codeword
    else
        p_i = i_state
    end
    seq = zeros(Int64,t_max)
    t_seq = []
    for i = 1:t_max
        seq[i] = p_i
        push!(t_seq, tokens[p_i])
        flip = rand() #flipping a coin for the creation of a novelty
        if flip <= p_nov
            t_ij = findall(x -> x==0, T_M[p_i,:]) #finding a new transition.
            if isempty(t_ij)
                t_ij = findall(x-> x!=0, T_M[p_i,:]) #find possible transitions.
                p_v = cumsum(T_M[p_i,t_ij]) / sum(T_M[p_i,t_ij])  #probability vector
                a = rand() #random number for choosing the transition
                new = findfirst(x-> x == a, sort([a;p_v])) #choosing the transition
                p_i = t_ij[new] #getting the new codeword
                #println(lenght(t_ij)," ",t_ij[new]," ",new)
            else
                p_i = rand(t_ij) #chooses one novelty randomly (uniform)
            end
        else
            t_ij = findall(x-> x!=0, T_M[p_i,:])
            if isempty(t_ij) #if there are no conventional codewords then chooses a novelty
                t_ij = findall(x-> x==0, T_M[p_i,:])
                p_i = rand(t_ij) #chooses one novelty randomly
            else
                p_v = cumsum(T_M[p_i,t_ij]) / sum(T_M[p_i,t_ij])  #probability vector
                a = rand() #random number for choosing the transition
                new = findfirst(x-> x == a, sort([a;p_v])) #choosing the transition
                p_i = t_ij[new] #getting the new codeword
                #println(length(t_ij)," ",t_ij[new]," ",new)
            end
        end
    end
    return seq, t_seq
end


function get_tran_mat(seq; normed=false)
    token_ref = sort(unique(seq))
    T_M = zeros(Int64, length(token_ref), length(token_ref))
    for i = 1:length(seq)-1
        x1 = findfirst(isequal(seq[i]), token_ref)
        x2 = findfirst(isequal(seq[i+1]), token_ref)
        T_M[x1,x2] += 1
    end
    return T_M, token_ref
end


function generate_markov_seq(T_M::Array{Int64,2}, t_max)
    t_list = findall(x-> x!=0, T_M) #finds the existing transitions
    p_i = rand(t_list)[1] #chooses randomly one initial condition, this can be fixed to start with a desired initial condition.
    out_seq = zeros(Int64,t_max) #this is the output sequence
    for i = 1:t_max
        out_seq[i] = p_i
        t_ij = findall(x-> x!=0, T_M[p_i,:])
        p_v = cumsum(T_M[p_i, t_ij]) / sum(T_M[p_i,t_ij])
        a = rand()
        new = findfirst(x-> x== a, sort([a;p_v]))
        p_i = t_ij[new]
    end
    return out_seq
end

function generate_markov_seq(T_M::Array{Int64,2}, t_max, i_state)
    t_list = findall(x-> x!=0, T_M) #finds the existing transitions
    p_i = i_state #chooses randomly one initial condition, this can be fixed to start with a desired initial condition.
    out_seq = zeros(Int64,t_max) #this is the output sequence
    for i = 1:t_max
        out_seq[i] = p_i
        t_ij = findall(x-> x!=0, T_M[p_i,:])
        p_v = cumsum(T_M[p_i, t_ij]) / sum(T_M[p_i,t_ij])
        a = rand()
        new = findfirst(x-> x== a, sort([a;p_v]))
        p_i = t_ij[new]
    end
    return out_seq
end

function get_stochastic_kseq(prob_keys)
    key_out = []
    for i = 1:length(prob_keys)
        if prob_keys[i] == "No Key/Notes"
            #
            #
        else
            key_list = prob_keys[i][2][:,1]
            p_vector = get_distros(prob_keys[i][2][:,2])
            p_cum = cumsum(p_vector)
            a = rand()
            nkey = findfirst(x-> x== a, sort([a;p_cum]))
            push!(key_out, key_list[nkey])
        end
    end
    return key_out
end
